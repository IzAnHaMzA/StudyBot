QUESTIONS

UNIT 1 TEST QUESTIOS 

Q1)Define operating system and list different types of operating systems.

Q2)State any 2 command line operating system and GUI based Operating system.

Q3)Define System Call and enlist it's types.

Q4)Draw the structure of Unix operating system.

Differentiate between multi tasking and multi programming.

Time sharing systems and real time system 



Q7)List and Describe any 4 services of Operating systems.

Q8)Explain different components of OS.

Q9)State any 2 features of Linux.

UNITQ.1Q.0
Q.1 What is operating system?

Q.2 What is the need of operating system?

Q.3 What are different components of operating system?

Q.4 Explain in detail different components of operating system.

Q.5 What are the different operations of operating system? Explain.

Q.6 Explain dual mode operation of operating system.

Q.7 Explain program management of the operating system.

Q.8 What are the different activities carried out in process management?

Q.9 Explain the events responsible for creation of process.

Q.10 What are the different resources in computer system?

Q.11 Explain resource management of the operating system.

Q.12 What is security and its goals? Explain.

Q.13 What is protection? What are the goals of protection?

Q.14 Write short note on timer.

Q.15 Explain Trojan horses and trap doors

Q.16 Explain protection domains with help of example.

Q.17 What is access matrix? Explain.

Q.18 What are the different views of operating system? Explain.

Q.19 Explain user's view and system view of operating system.

Q.20 What are the different types of operating systems?

Q.21 Explain batch operating systems.

Q.22 Explain Multiprogrammed Operating Systems.

Q.23 Explain Time Shared Operating Systems.

Q.24 Explain Multiprocessor systems.

Q.25 Explain mainframe operating systems.

Q.26 What is distributed systems? Explain.

Q.27 Explain distributed operating system.

Q.28 Explain network operating system.

Q.29 Differentiate between distributed operating system and network operating system.

Q.30 What is real time systems? Explain in detail.

Q.31 What is mobile OS? Explain.

Q.32 Explain Android operating system.

Q.33 What are design goals of android OS?

Q.34 Explain architecture of android OS.

Q.35 Explain iOS?

Q.36 Difference between Time sharing System and Real Time System.

Q.37 Difference between Multiprogramming and Multitasking.

Q.38 Write short note on disk operating system.

Q.39 Explain features of disk operating system.

Q.40 Explain directory structure of disk operating system.

Q.41 Explain file structure of disk operating system.

Q.42 What are Internal and External Commands in DOS?

Q.43 Explain history of UNIX in short.

Q.44 What are the goals of UNIX OS?

Q.45 Explain interfaces to UNIX OS.

Q.46 Explain UNIX shell and utility programs.

Q.47 Explain Information, File, Process/Memory Management in UNIX.

Q.48 Explain history of Windows OS.

Q.49 What are Microsoft's design goals for Windows OS? Explain.

Q.50 Explain different system components of Windows OS.

Q.51 Explain history of Linux OS.

Q.52 Explain features of Linux OS.

Q.53 Explain components of Linux OS.

Q.54 Differentiate between MS DOS and Windows.

Q.55 Differentiate between GUI and CUI.

Q.56 What are the advantages of Linux/UNIX over Windows? Explain.

Q.57 Explain in brief services provided by operating system.

Q.58 What is system calls? Explain its categories.

Q.59 Explain the different types of system calls.

Q.60 Give some examples of system calls with explanation.

Q.61 What are the different component of operating system? Explain.

Q.62 Explain in short process management component of operating system.

Q.63 Explain in short main memory management component of operating system.

Q.64 Explain in short storage management component of operating system.

Q.65 Explain in short file management component of operating system.

Q.66 Explain in short I/O management component of operating system.

Q.67 Explain in short secondary storage management component of operating system.

UNITQ.2

Q.1What is process?

Q.2.What are the different states of process ?

Q.3.Explain process state transition diagram.

Q.4.What is process control block (PCB)? Explain in detail.

Q.5.What are the different fields in process control block? Explain.
Q.6 What are different scheduling queues?

Q.7 Explain Queuing-diagram representation of process scheduling.

Q.8 Explain different types of schedulers.

Q.9 Differentiate between Long-term, short-term and medium-term schedulers.

Q.10 What is context switch ?

Q.11 Explain the principle of concurrency. Give example.

Q.12 Explain inter-process communication.

Q.13 Explain how shared memory is used for inter-process communication.

Q.14 Explain how message passing is used for inter-process communication.

Q.15 What is thread? Explain its advantages over process.

Q.16 Differentiate between process and thread.

Q.17 Explain user level and kernel level threads with advantages and disadvantages.

Q.18 What is multithreading?

Q.19 Explain different types of multithreading models.

Q.20 Explain the use of following commands with syntax and output :ps, walt, sleep, kill, exit

UNITQ.3

Q.1 What are the objectives of scheduling?

Q.2 What is CPU and I/O burst Cycles?

Q.3 What is the difference between Pre-emptive and Non-Pre-emptive Scheduling?

Q.4 Explain different criteria for scheduling.

Q.5 Explain First Come First Served scheduling (FCFS) algorithm with example.

Q.6 Explain Shortest Job First (SJF) scheduling algorithm with example.

Q.7 Explain Priority scheduling algorithm with example.

Q.8 Explain Shortest Remaining Time Next (SRTN) scheduling algorithm with example

Q.9 Explain Round Robin (RR) scheduling algorithm with example.

Q.10 Explain Multilevel Queue Scheduling algorithm with example.

Q.11 What is deadlock?

Q.12 Explain deadlock with system model.

Q.13 Explain necessary condition to occur the deadlock.

Q.14 What is resource allocation graph? Explain with example.

Q.15 Explain deadlock prevention in detail.

Q.16 What are the necessary conditions for deadlock situation to arise ?

Q.17 How you can prevent deadlock by preventing circular wait condition?

Q.18 Explain safe state and safe sequence with example for deadlock avoidance.

Q.19 Explain deadlock avoidance.

Q.20 Explain Resource-Allocation Graph Algorithm.

Q.21 Explain Bankers algorithm for deadlock avoidance with suitable example.

Q.22 Explain Resource-Request Algorithm.

Q.23 Explain various steps in safety algorithm deadlock avoidance.

UNITQ.4Q.01 Why it is necessary to manage the memory? explainQ.0Q.2 Explain mono programming concept used in early computer systemsQ.0Q.3 What are the benefits of multiprogramming? ExplainQ.04 Explain multiprogramming with Fixed and Variable Partitions techniques.

Q.5 What are the different operations of operating system? ExplainQ.0Q.6 Explain contiguous allocation of memoryQ.0Q.7 Differentiate between fixed and variable partition in contiguous memory allocation.

Q.8 What is fragmentation ? Explain internal and external fragmentation.

Q.9 Explain difference between internal and external fragmentation.

Q.10 Explain process of compaction with the example.

Q.11 How to solve the problem of external fragmentation?

Q.12 Explain different Free Space Management Techniques.

Q.13 Explain bit-map and linked list Free Space Management Techniques. State advantages and Disadvantages.

Q.14 Explain virtual memory concept.

Q.15 Explain paging concept.

Q.16 Explain the paging model of physical and logical memoryQ.0Q.17 Explain operation of paging hardware.

Q.18 Explain paging with example.

Q.19 Explain how Memory Protection and Sharing supported by pagingQ.0Q.20 Explain segmentation with the help of example.

Q.21 Differentiate between paging and segmentation.

Q.22 How virtual memory concept is implemented by demand paging ? Explain.

Q.23 Write short note on demand paging.

Q.24 What are the advantages and disadvantages of demand paging?

Q.25 Under what circumstances do page fault occurs. Describe action taken by operating system when page fault occurs

Q.25 Give steps that are involved in page fault occurrence.

Q.27 What is Belady's anomaly ? Which page replacement algorithm suffer from such anomaly ?

Q.28 Explain various page replacement algorithms with exampleQ.0Q.29 How optimal page replacement algorithm works? Explain with exampleQ.0Q.30 How FIFO page replacement algorithm works? Explain with exampleQ.0Q.31 How least recently used page replacement algorithm works? Explain with example.

Q.32 Explain implementation of least recently used page replacement algorithm using stackQ.0Q.33 Explain implementation of least recently used page replacement algorithm using counters

UNITQ.5 
Q.1 What do you mean by file and file system? ExplainQ.0Q.2 Explain the file concept in operating systemQ.0Q.3 Define the file systemQ.0Q.4 Explain different file attributes.

Q.5 What are the different file operations over a file? Explain them.

Q.6 What are different types of file?

Q.7 What are the different ways to structure the files?

Q.8 Explain different file access methods.

Q.9 Explain contiguous allocation of files with its advantages and disadvantages.

Q.10 Explain linked allocation of files with its advantages and disadvantages.

Q.11 Explain indexed allocation of files with its advantages and disadvantages.

Q.12 Describe different schemes for defining the logical structure of directory.

Q.13 Explain directory structure in operating system.

Q.14 Describe directory structure in detail.

Q.15 Explain physical structure of hard disk.

Syllabus 
OPERATING SYSTEM
Course Code: Q.315319
Semester: Q.5 (K Scheme)
Programme Names: Artificial Intelligence, Artificial Intelligence & Machine Learning, Cloud Computing & Big Data, Computer Technology, Computer Engineering, Computer Science & Engineering, Data Sciences, Computer Hardware & Maintenance, Information Technology, Computer Science & IT, Computer Science
Programme Codes: AI / AN / BD / CM / CO / CW / DS / HA / IF / IH / SE
________________________________________
I. RATIONALE
An Operating System is to manage a Computer Hardware and software resources efficiently and provide user friendly environment. An Operating System is a System Program that controls the execution of application program and acts as an interface between applications and the computer hardware. It also plays a crucial role in maintaining system security, protecting data and ensuring that processes do not interfere with one another.
This course enables learning of internal functioning of Operating System and helps in identifying appropriate Operating System for given Applications/Tasks.
________________________________________
II. INDUSTRY / EMPLOYER EXPECTED OUTCOME
•	Interpret features of Operating System.
________________________________________
III. COURSE LEVEL LEARNING OUTCOMES (COs)
•	CO1: Explain the services and components of an Operating System.
•	CO2: Describe aspects of Process Management in an Operating System.
•	CO3: Implement CPU Scheduling algorithms and evaluate their effectiveness.
•	CO4: Analyze Memory Management techniques used by an Operating System.
•	CO5: Apply techniques for effective File Management in an Operating System.
________________________________________
IV. TEACHING-LEARNING & ASSESSMENT SCHEME
•	Course Code: Q.315319
•	Course Title: Operating System (OSY)
•	Category: DSC
•	Credits: Q.5
•	Contact Hours/Week: Q.9 (Q.5 CL + Q.2 TL + Q.2 LL)
•	Assessment Scheme:
o	Theory: Q.100 Marks (FA-THQ.30, SA-THQ.70)
o	Practical: Q.75 Marks (FA-PRQ.25, SA-PRQ.25, SLAQ.25)
o	Total: Q.175 Marks
________________________________________
V. THEORY LEARNING OUTCOMES & CONTENT
Unit I – OS Services & Components
•	Concept, functions, types (Batch, Multi-programmed, Time Shared, Multiprocessor, Distributed, Real Time, Mobile OS)
•	Command Line OS: DOS, UNIX | GUI OS: Windows, Linux, MacOS
•	System Calls, OS Components: Process, Memory, File, I/O, Secondary Storage Management
Unit II – Process Management
•	Process states, PCB, Scheduling (queues, schedulers, context switch)
•	Interprocess Communication (Shared Memory, Message Passing)
•	Threads (User & Kernel, Models)
Unit III – CPU Scheduling
•	CPU & I/O burst cycle, Preemptive vs Non-preemptive scheduling
•	Algorithms: FCFS, SJF, SRTN, RR, Priority, Multilevel Queue
•	Deadlock (conditions, prevention, avoidance – Banker’s Algorithm)
Unit IV – Memory Management
•	Partitioning (Fixed, Variable), Free Space (Bitmap, Linked List)
•	Swapping, Compaction, Fragmentation
•	Paging, Segmentation, Virtual Memory, Page Replacement (FIFO, LRU, Optimal)
Unit V – File Management
•	File concepts, operations, types, structure
•	Access methods (Sequential, Direct), Allocation methods (Contiguous, Linked, Indexed)
•	Directory structures (Single, Two-level, Tree)
________________________________________
VI. LABORATORY LEARNING OUTCOMES
•	Execute system call commands in Linux (fork, exec, getpid, pipe, etc.)
•	Process-related commands (ps, kill, wait, sleep, nice, renice, bg, fg)
•	IPC commands (who, wall, write, mesg, ipcs)
•	Programs for Scheduling (FCFS, SJF, Priority, RR)
•	Banker’s Algorithm implementation
•	Memory management commands (df, free, vmstat, htop)
•	Page Replacement algorithms (FIFO, LRU)
•	File allocation methods
________________________________________
VII. MICRO PROJECTS / ASSIGNMENTS
•	Page Fault calculation using FIFO, LRU, Optimal algorithms
•	CLI vs GUI OS comparison
•	Process vs Thread differences
•	File allocation methods study (Contiguous, Indexed)
•	Report on different types of Operating Systems
•	Compare Memory Allocation strategies (First Fit, Best Fit, Worst Fit)
________________________________________
VIII. REQUIRED LAB EQUIPMENT
•	Computer system with Linux/Ubuntu/CentOS or equivalent
________________________________________
IX. SPECIFICATION TABLE
•	Unit I: Q.14 Marks
•	Unit II: Q.14 Marks
•	Unit III: Q.16 Marks
•	Unit IV: Q.16 Marks
•	Unit V: Q.10 Marks
•	Total: Q.70 Marks
________________________________________
X. ASSESSMENT
•	Formative: Process (Q.60%), Product (Q.40%)
•	Summative: End Semester Exam, Lab performance, Viva-voce
________________________________________
XI. CO–PO MATRIX
•	CO1 → PO1, PO4, PO7
•	CO2 → PO1, PO4, PO5
•	CO3 → PO1, PO2, PO3, PO4, PO5
•	CO4 → PO1, PO2, PO3, PO4, PO5, PO7
•	CO5 → PO1, PO2, PO3, PO4, PO5, PO7
________________________________________
XII. SUGGESTED BOOKSQ.1.	Dhananjay M. Dhamdhere – Operating System: A Concept-Based ApproachQ.2.	William Stallings – Operating Systems: Internals and Design PrinciplesQ.3.	Richard Petersen – Linux The Complete ReferenceQ.4.	Richard Blum – Linux Command Line and Shell ScriptingQ.5.	Silberschatz & Peterson – Operating System Concepts
________________________________________
XIII. LEARNING RESOURCES
•	NPTEL: Introduction to Operating Systems
•	GeeksforGeeks: Processes in Linux/Unix
•	Ubuntu Desktop Installation Guide
•	RedHat Linux download portal
•	DigitalOcean tutorials on Linux commandsQ.1-Q.1Q.1.Operating System Services and Components

SyllabusQ.1Q.1 Operating System: concept, functionsQ.1Q.2 Different types of Operating System: Batch Operating System, Multi-programmed. Time Shared Operating System. Multiprocessor System, Distributed System, Real Time System, Mobile OS (Android OS)

Q.1Q.3 Command line based Operating System: DOS UNIX GUT based Operating System: WINDOWS.INUX, MAC OSQ.1Q.4 Different Services of Operating System, System Calls: Concept, types of system callsQ.15 Operating System Components: Process Management, Main Memory Management, File Management, Q.10 Management, Secondary Storage ManagementQ.1Q.1 Introduction to Operating System

OPERATING SYSTEM SERVICES AND COMPONENTS

1.1 INTRODUCTION TO OPERATING SYSTEM

An operating system is system software which manages, operates and communicates with the computer hardware and software.

To complete the execution, a user program needs many resources.

The main job of the operating system is to provide resources and services to the user program. So without operating system, a computer would be useless.

An operating system acts as an interface between the user and hardware of the computer and also controls the execution of application programs.

Operating system is also called as resource manager.

1.1.1 Need of Operating System

Basically operating systems perform tasks, for example identifying input from the input devices such as keyboard, mouse etc and sending output to the output devices such as monitor, printer etc and keeping track of files and directories on the disk, and controlling peripheral devices such as secondary storage devices, printers, scanners, audio mixer.

The heart of a computer system is a processing unit called CPU.

User's program should get the processing unit to complete the execution and computer system should offer the service to allocate processing unit to user's program.

The operating system allocates memory to user program as per need. In the same way, user programs interact with the other user programs through devices like keyboard, or a mouse or even a joystick.

1.1.2 Components of Operating System

QUESTIONS:
- List components of OS. Explain process management in detail.
- Explain different components of Operating system.

Pg1END

1.2 OPERATING SYSTEM SERVICES AND COMPONENTS

Operating system consists of many components. Each component of the operating system has its own set of defined inputs and outputs. Different components of OS perform precise tasks to offer the overall functionality of the operating system. The most important functions of the operating system are as follows:

1. Process Management
2. Memory Management
3. File Management
4. Device Management
5. Protection and Security
6. User Interface or Command Interpreter
7. Booting the Computer
8. Performs basic computer tasks

1.2.1 Process Management

The process management activities involve:

1. To provide control access to shared resources like file, memory, I/O and CPU.
2. Control the execution of user applications.
3. Creation, execution and deletion of user and system processes.
4. Resume a process execution or cancel it.
5. Scheduling of a process.
6. Synchronization, interprocess communication and deadlock handling for processes.

1.2.2 Memory Management

The memory management activities handled by operating system are:

1. Allocation of memory to the processes.
2. Free the memory from process after completion of execution.
3. Reallocation of memory to a program after used block becomes free.
4. Keep track of memory usage by the process.

1.2.3 File Management

The file management activities of operating system consist of:

1. Creation and deletion of files and directories.
2. Provide access to files and allocation of storage space for files.
3. Maintain back-up of files.
4. File Security.

1.2.4 Device Management

The device management tasks include:

1. To open, close and write device drivers.
2. Communicate, control and monitor the device driver.

1.2.5 Protection and Security

The resources of the system are protected by the operating system. User authentication, file attributes such as read, write, encryption and back-up of data are used by operating system to give necessary protection.

Pg2END

1.2.6 User Interface or Command Interpreter

The role of operating system is to work as interface between the user and hardware of the computer. This Interface is provided by operating system through set of commands or it is a Graphical User Interface (GUI).

1.2.7 Booting the Computer

The process of starting or restarting the computer is known as booting. If computer is switched off completely and if turned on then it is called cold booting. A warm booting is the process of using the operating system to restart the computer.

1.2.8 Performs Basic Computer Tasks

The different peripheral devices such as the mouse, keyboard and printers are managed by operating system. Nowadays most operating systems are plug and play which means any device will automatically be detected and configured without any user interference.

1.3 Operations of Operating System

Modern operating systems are Interrupt driven. Operating system sits idle and waits in case if there are no processes to execute, no I/O devices to offer service and there is no user to whom response is to be given.

In this case operating system just waits for something to happen. When Interrupt or trap occurs then events are signaled.

If abnormal condition arises in system during program execution, then it is detected by CPU is called trap.

Trap occurs exactly at same point of time of program execution. Software interrupts are trap or exceptions. Example is division by zero.

After receiving an interrupt, operating system carries out some housekeeping so that it can resume its computation once it is through servicing the interrupt.

After this a searching is carried out in the interrupt vector or Interrupt table.

This table remains in kernel-memory space and includes address of the code in the device driver that is to service the Interrupt.

The Interrupt handler is then executed. When the handler finishes, control of the CPU is returned to the code that was executing before the interrupt occurred.

Interrupt routine (ISS) deals with Interrupts.

The design of the operating system should be in such a way that one erroneous or malicious program should not affect other programs.

1.3.1 Dual Mode Operation

There are two modes of operating system:

The majority of CPUs support at least two modes of operation, i.e., kernel mode and user mode.

In kernel mode, all instructions are allowed to be executed, and the entire set of all registers is accessible throughout the execution.

On the contrary to this, in user mode, memory and register access is restricted. The CPU gets switched to kernel mode while executing operating system code.

The only means to switch from user mode to kernel mode is through system calls as implemented by the operating system.

Hardware contains mode bit which indicates kernel mode when 0 and user mode when set to 1. When user application is running then system is in user mode.

Pg3END

When user application requests the service from operating system then transition from user mode to kernel mode takes place.

During booting of the system, hardware is in kernel mode. Once the operating system is loaded and starts executing user application, system goes in user mode.

Due to dual mode operation, protection from misbehaving users is achieved. This protection can be provided by allowing the execution of privileged instructions in kernel mode only.

Any attempt to execute these privileged instructions in user mode causes trap to operating system.

The instruction to enter in user mode, Instructions for I/O control, timer management, and Interrupt management are some of the examples of privileged instructions.

From user mode, control is switched to operating system through interrupt, a trap, or a system call.

The interface between OS and user programs is defined by the set of system calls that the operating system offers.

System call is the call for the operating system to perform some task on behalf of the program.

Therefore system calls make up the interface between processes and the operating system.

There are two ways for the process to switch from the user mode to the kernel mode:

One is when a user process explicitly requests to enter in kernel by issuing a system call.

Other is, during the execution of user process kernel can take over to carry out some system housekeeping task.

1.3.2 Timer

Computer contains crystal clocks containing crystal oscillator, a counter, and a holding register.

A quartz crystal under tension produces a periodic signal of very high accuracy, usually in the range of several hundred megahertz to a few Gigahertz, depending on the crystal chosen.

By electronic circuitry, this base signal can be multiplied by a small integer to get frequencies up to several gigahertz and more than this.

Computer contains at least one circuit, which produces synchronizing signal and gives it to many circuits in computer.

This synchronizing signal is fed into the counter to make it count down to zero. When the counter gets to zero, it causes an interrupt.

In one-shot mode, after the clock is started, holding register value gets copied into the counter and then decrements the counter at each pulse from the crystal.

When the counter value becomes zero, it causes an interrupt and stops until it is explicitly started again by the software.

In square-wave mode, after getting to zero and causing the interrupt, the holding register is automatically copied into the counter, and the whole process is repeated again indefinitely.

These periodic interrupts are called clock ticks. Every computer has a battery-powered backup clock to save the current time when machine is switched off.

Universal coordinated time is used to synchronize the clocks of the machines.

Operating system ensures to set timer to interrupt before handing over the control to user application.

1.4 Program Management

A program or application under execution is called as process. A process includes the execution context.

A program resides on the disk. On disk it does not require any resources.

Pg4END

A program gets executed in main memory. So it should be transferred from disk to memory. Files etc. To complete execution, program needs many resources and competes for it. These resources are memory, CPU.

Now it becomes process. From the computation context point of view, a process is defined by CPU state, memory contents and execution environment.

Process manager implements the process management functions.

In multiprogramming, single CPU is shared among many processes.

If many processes remain busy in completing I/O, CPU is allocated to only one process at a given point of time.

Here some policy is required to allocate CPU to process, called as CPU scheduling.

If multiple users are working on the system, operating system switches the CPU from one user process to other.

User gets the illusion that only he or she is using the system.

Process synchronization mechanism is required to ensure that only one process should use critical section.

Process communication and synchronization, deadlock handling, suspension and resumption of processes and creation and deletion of the processes etc. are some of the activities performed in process management.

Program counter contains address of the instruction from which execution resumes after context switch.

The process management activities involve:

1. To provide control access to shared resources like file, memory, I/O and CPU.
2. Control the execution of user applications.
3. Creation, execution and deletion of user and system processes.
4. Resume a process execution or cancel it.
5. Scheduling of a process.
6. Synchronization, interprocess communication and deadlock handling for processes.

A CPU state is defined by the content of the various registers such as Instruction Register(IR), Program Counter (PC), Stack Pointer (SP) and general purpose registers.

A small amount of data is stored in CPU registers. Memory contains program code and its predefined data structures. Heap is reserved memory area for dynamically allocation of memory to the program at run time.

In stack, program local variables are allocated and return values of function call are stored. Some register values are also saved in stack.

Execution environment includes open files, communication channels to other processes etc. Following are the components of the process:

1. The object code that is to be executed.
2. Resources required by the program to complete the execution.
3. The data on which program will operate.
4. Program execution state.

Processes are created because of the following four principal events. These are:

1. System Initialization: When an OS is booted, typically several processes are created. Execution of a process creation system call by a running process. Often a running process will issue system calls to create one or more new processes to help it do its job. Creating new processes is particularly useful when the work to be done can easily be formulated in terms of several related, but otherwise independent interacting processes.

2. A user request to create a new process: In Interactive systems, users can start a program by typing a command or (double) clicking an icon.

Pg5END

3. Initiation of a batch job: Here users can submit batch jobs to the system (possibly remotely). When the OS decides that it has the resources to run another job, it creates a new process and runs the next job from the input queue in it.

During the execution, process can create new process by using create process system call. The process which creates new process is called a parent process, and the new processes are called the children of that process.

Newly created processes may in turn create other new processes, creating a tree of processes. In UNIX or the Windows family of operating systems processes are identified by unique process identifier (or pid), which is typically an integer number. The ps command is used in UNIX to obtain the listing of processes. By using command ps -el complete information for all processes currently active in the system can be obtained.

Process requires certain resources like CPU time, memory, files, I/O devices to complete its task. The subprocess also needs these resources. Subprocess can get its needed resources directly from the operating system, or it may be forced to a subset of the resources of the parent process.

The parent can share the resources among its children or it can divide the resources to allocate to its children. If child process is restricted to a subset of the parent's resources, overloading the system by creating too many subprocesses can be avoided. The initialization data may be passed along by the parent process to the child process after creation of the process.

After creation of a new process, two possibilities exist related to execution:

1. The parent carries on executing in parallel with its children.
2. The parent waits until some or all of its children have terminated.

There are also two possibilities related to the address space of the new process:

1. The child process may have same program and data as the parent. That is it is duplicate of parent.
2. The child process has a new program loaded into it.

1.5 Resource Management

From the computer's point of view, the operating system is the program most closely involved with the hardware. In this context, we can view an operating system as a resource allocator.

Resource: There are many resources available in the systems. For example CPU, memory (RAM), file-storage space, I/O devices (disk), files, printers and so on.

The OS acts as the manager of these resources. It decides which resource should be given to which program, for how much time and after use it reclaims the resource. Each program gets:

1. Time with the resource.
2. Space on the resource.

Multiple users/applications can share the resources. The reasons for sharing are:

1. The devices are expensive, so sharing saves the cost.
2. The data needs to be shared as well as needs to be communicated.

Facing numerous and possibly conflicting requests for resources, the OS must decide:

1. How to allocate them to specific programs (processes, jobs)?
2. How to protect applications from one another?
3. How to provide fair and efficient access to resources?
4. How to operate and control the various I/O devices?

Pg6END

1.6 Security and Protection

1.6.1 Security and its Goals

The security breach or misuse of the system can be classified as purposeful (malicious) or unintentional (accidental). It is easy to deal with accidental misuse compared to malicious misuse. The protection mechanisms are basically designed for protection from accidents.

The system is secure if its resources are used and accessed as proposed under all conditions. Total security is impossible to achieve. We must have mechanisms to make security breaches an exceptional occurrence, rather than the rule. The challenge in developing operating systems security is to design security mechanisms that safeguard process execution and their generated data in an environment with complex interactions.

The protection of the system considers and concerns only about internal environment of the system. In contrast, security requires consideration of the external environment within which the system functions. Only sufficient protection system is not enough for total security. Protection mechanisms refer to the particular operating system mechanisms which are used to protect information in the computer. Security encompasses the overall problem of security.

Security has many aspects. Three of the more important ones are:

1. The nature of the threats.
2. The nature of intruders.
3. Accidental data loss.

Trojan Horses:

Trojan horse is program segment that exploits its environment. It is one of the hoary insider attacks. It is apparently innocent program that includes code to do an unpredicted and unwanted function. These functions can be modifying, deleting or performing the encryption on user's files. It can also copy the file to a particular place where cracker can recover it. It can be placed on internet as a game or any file to attract the user attention. After that if user downloads and runs it then Trojan horse gets invoked to perform unexpected operations.

Trap Doors:

Trap doors are pieces of code embedded in programs by the designer to get access quickly at a later time, often at the time of the testing or debugging phase. If a dishonest programmer deliberately leaves this code in or simply does not remember to remove it, a potential security hole is introduced. It is impossible to remove in reliable way. Only solution is to reformat the system. It is also possible to include the intelligent trap door in compiler to generate it along with the object code after compilation.

Intruders:

Intruder is the most well-known threat to security, generally referred to as hacker or crackers. Passive Intruders want to read file in unauthorized way. Active intruders want to make unauthorized changes to data.

Accidental Data Loss:

Apart from threats by intruders, important data can be lost by accident. Some of the common causes of accidental data loss are:

1. Natural calamity or Act of God: Fires, floods, earthquakes, wars, riots, or rats chewing tapes or Floppy disks.
2. Hardware or software errors: Error in reading disks or tapes, communication errors, device errors, CPU malfunctioning etc.
3. Human errors: Incorrect data entry, wrong program run, lost disk or tape, or some other mistake.

Pg7END

1.6.2 Goals of Protection

Protection mechanisms refer to the particular operating system mechanisms which are used to protect information, files and resources in the computer. Policy means whose data should be protected from whom and mechanism is how system puts into effect these policies.

In some systems, a program called reference monitor is used to impose a protection. Any attempt to access the resource is verified by reference monitor whether it is legal or not. The reference makes a decision on the basis of policy table.

Modern protection mechanism has developed to improve the reliability of any complex system in which use of shared resources is involved. There are many reasons to offer the protection.

It is needed to provide the protection to avoid mischievous, deliberate violation of an access restriction by a user. It is necessary to make sure that each program component running in the system uses system resources as per defined policies to ensure the reliability of the system.

Policies to make use of the resources of computer system are put into effect by mechanism which is offered by protection. Some of the policies are included in the design of the system. Other policies are decided by the management of a system. Many policies are defined by the individual user of the system to protect their own files and programs.

A protection system should be flexible enough to offer different and put into effect the different types of policies. Different types of applications have different types of resource use. The policies designed should allow to offer this resource use need. The resource use of the applications can change over the period of time. Hence, instead of relying totally on operating system, application programmer should use protection mechanism to protect the resources created against misuse.

1.6.3 Protection Domains

The system contains many hardware objects such as CPUs, memory segments, disk drives, printers, magnetic tapes and many software objects such as processes, files, databases, or semaphores. Each object can be referenced by its unique name. On every object a finite set of operations can be performed. For example, WAIT and SIGNAL on semaphores and READ and WRITE on files.

A system should enforce a mechanism, to restrict the processes from accessing the needed objects for which they are not unauthorized. The mechanism should also ensure to restrict processes to a subset of the legal operations when that is needed.

For example, process P has a permission to read file F but not of performing write operation on it. A set of object and rights pair is called domain. Each pair denotes an object and some subset of the operations that can be performed on it. One domain corresponds to one user and specifies the permissions to user for certain activities. Consider the following three domains as shown in Fig 1.1:

Domain 1:
- File A (RW)
- File B (R)

Domain 2:
- File C (R)
- File D (RWX)
- File E (RW)

Domain 3:
- Printer A (W)
- File F (RW)
- File G (RWX)

Figure 1.1: Protection Domains

Pg8END
It is possible for the same object to be in multiple domains. [Read, Write, Execute] rights are available on each object. At a particular time of execution, each process executes in some protection domain.

In that domain there is some set of objects it can access, and for each object it has some set of rights shown in square brackets.

During execution, processes can go from one domain to other domain. The rules for domain switching are very much dependent on and varies from system to system.

In Unix every process is defined by user-id and group-id (uid, gid). Two processes with the similar (UID, GID) combination will have access to precisely the same set of objects. Process often switches from user area to kernel area, that is, from one domain to other. The kernel part has access to a different set of objects from the user part.

1.6.4 Access Matrix

The kernel part has access to a different set of objects from the user part.

System keeps track on which object belongs to which domain by using access matrix. The matrix for above Fig 1.1 is shown in Fig 1.2.

The system can tell if an access to a given object in particular manner from a specified domain is permissible. For this purpose, system makes use of this matrix and the current domain number.

Access Matrix:

                    File A    File B    File C    File D    File E    File F    File G    Printer A
Domain 1            RW        R         -         -         -         -         -         -
Domain 2            -         -         R         RWX       RW        -         -         W
Domain 3            -         -         -         -         -         RW        RWX       -

Figure 1.2: Access Matrix for Fig 1.1

It is possible to switch domain in the matrix model by considering that a domain is itself an object, with the action "enters". Processes in domain1 are allowed to go in domain2, but once it is in domain2, they cannot go back to domain1. This situation models executing a SETUID program in UNIX. In this example, other domain switches are not permitted.

Domain Switching Matrix:

                    File A    File B    File C    File D    File E    File F    File G    Printer A    Domain 1    Domain 2    Domain 3
Domain 1            RW        R         -         -         -         -         -         -            -           Enter 1     -
Domain 2            -         -         R         RWX       RW        -         -         W            -           -           Write 3
Domain 3            -         -         -         -         -         RW        RWX       -            -           -           -

Figure 1.3: Matrix model with domain switching

Pg9END

1.7 Different Views of Operating System

Different views of an operating system are Application View, User View, System View and implementation view.

1.7.1 Application View

In application view, we consider the services provided by operating system. Operating System is responsible to provide the needed execution environment to the running programs. The program needs processor, memory space and other resources during execution.

This is exactly provided by execution environment. The program uses network, storage devices, and hardware components through interfaces. These interfaces are also provided by execution environment. Interfaces provide a simplified, abstract view of hardware to application programs. Undesirable interaction between concurrent running programs is prevented by execution environment making them isolated from each other.

1.7.2 Users View

If the user is working on the single autonomous PC for his work, then performance is mostly taken into consideration. Operating system is designed to give ease of use and gaining performance. In this case attention will not be given to optimum resource utilization.

If many users working on workstations connected to mainframe, minicomputers or servers, they share the resources of the servers. This is because all access the same machine for their work. The exchange of information takes place among the users.

The operating system is designed to maximize resource utilization. In recent times, many varieties of handheld computers such as Personal Digital Assistant (PDA), Handheld Personal Computer (HPC) and Modern Cellular Phones etc. have come into fashion.

These devices are used by single user. Some are connected to networks, either directly by wire or through wireless modems. Since devices operate by battery power, there is limitation of power. Due to the limitation of power and interfaces, the remote operations of these devices are also limited. Again operating systems for these devices are designed mostly for individual usability, but performance per amount of battery life is important as well.

1.7.3 System View

The operating system is called as resource manager. It manages the hardware resources of a computer system. Resources include processors, memory, disks and other storage devices, network interfaces, I/O devices such as keyboards, mice and monitors, so on.

The running program needs resources and operating system allocates it. Some of the resources are sharable and some not. The operating system controls the sharing of the resources among many programs that are executing.

1.7.4 Implementation View

The operating system is implemented as concurrent, real-time program. Concurrency in operating system is due to the requirement of supporting the concurrent applications. Also operating system should directly interact with the hardware which imposes timing constraints.

The execution environment contains the abstract entities like files and file system, processes and threads, address spaces, sockets, pipes etc. These entities are manipulated by running program.

Pg10END

2. DIFFERENT TYPES OF OPERATING SYSTEMS       

QUESTIONS:
- Enlist types of operating system.

The classification of the different operating systems is given below along with a few examples of operating systems that fall into each of the categories. Many computer operating systems will fall into more than one of the following categories:

1. Multi-user
2. Multiprocessing
3. Multitasking
4. Multithreading
5. Real time

2.1 Multi-user

In multiuser operating system multiple users can work on same computer simultaneously. Some operating systems allow hundreds or even thousands of parallel users working on the system.

Following are some examples of multi-user operating systems: Linux, UNIX, Windows 2000, Windows .NET.

2.2 Multiprocessing

Multiprocessing operating system supports for multiple CPU in a system. It supports for allocation of different CPU to multiple threads of the program. Due to parallel execution of the threads, efficiency and performance can be achieved.

Following are some examples of multiprocessing operating systems: Linux, UNIX, Windows 2000.

2.3 Multitasking

Operating system which supports for multitasking, permits for execution of many software processes at the same time. Multiple tasks are handled concurrently.

Following are some examples of multitasking operating systems: UNIX, Windows 2000.

2.4 Multithreading

A single program can have multiple threads that can run in parallel. The operating system supporting for multithreading can divide the program in multiple threads that can run in parallel.

Such operating systems that would fall into this category are:

- Linux
- UNIX
- Windows 2000

2.5 Real Time

For Real time operating systems time constraints are a key parameter.

If the completion of particular task should happen in given time constraints or action completely must take place at a certain instant or within a certain range.

Real time operating systems must respond quickly. All above OS like UNIX, Windows are not real time OS.

Categories of operating systems are explained in further sections.

Pg11END

2.1.1 Batch Operating System

In earlier days programmers used to write their programs by using punched cards. Normally at that time, mainframe computer system used to be a resident at a computer system centre with controlled environment. Punched cards were holding the instructions of programs in encoded form. This was done by punching the card. Card was holding the instruction in binary form. Among the deck header cards which were "Job control cards" would specify compilers needed to compile the program.

The operators at the computer system would group the job as per programming languages. The jobs which required long processing time were classified as long jobs and which had short processing time was classified as "short jobs".

The entire processing was batch processing on the basis of set of jobs. There was no user interaction in processing the jobs. The processor would remain busy at a time in processing one program. If any I/O required, then processor would wait as processor speed is high with compare to I/O speed. As a consequence of this processor utilization was poor and would remain idle for most of the time. In this scenario only one program was kept in the memory at the time of execution.

This operating system does not permit the user to interact with executing program. Job scheduling in this type of OS in order of arrival that is first come first serve basis.

Accesses to files are serial. Therefore, file management is simple as no protection is required. As in one part of memory OS resides and other part is used to load transient program for execution, the memory management is also simple.

These systems are better for long jobs and user interaction not needed. CPU remains busy all the time so its utilization is increased.

Limitations of these types of system are smaller processes needs to wait for other jobs or processes, time consuming and data is supplied in batch so delay is caused.

2.1.2 Multiprogrammed Operating Systems

QUESTIONS:
- Explain multiprogramming OS in detail.

Multiprogramming is required to support multiple processes simultaneously. Since multiple processes are resident in memory at the same time, it increases processor utilization if the processes are I/O bound.

CPU does not remain idle. CPU utilization increases as it executes multiple processes on time sharing basis. Multiprogramming gives illusion of running multiple processes at once and provides users with interactive response to processes.

As single user cannot keep either CPU or I/O devices busy all the time, operating system supports multiprogramming.

In multiprogramming, operating system organizes the jobs in such a way that the CPU always get one job to execute. Hence, Multiprogramming improves CPU utilization.

Multiple jobs remain in memory so that CPU can take any one for processing.

During processing of job if I/O is required then CPU does not remain idle it takes other job for processing till I/O completes.

Modern all personal computer operating systems support for multiprogramming. At the boot time itself, several programs starts up. These are single user as well as multiuser operating systems and offer good support to the single user or multiple users.

Word processing, spreadsheets, games, and Internet access are some of the common use of these operating systems. UNIX, Linux, FreeBSD, Windows 7, Windows 8, and Apple's OS X are some of the examples of these operating systems.

Pg12END

2.1.3 Time Shared Operating Systems

QUESTIONS:
- Describe working of time sharing system with nest diagram.

Time sharing system diagram:

User 3
User 4
User 2
    CPU
User 5
(Active state)

User
User
(Ready state)

Figure 2.1: Time Sharing System

User1, User2, User3 and User4 are in waiting state. They are waiting for I/O operation. More than one user can be in this state. User5's program is under execution and User6's program is ready to execute and waiting for its next turn for CPU.

Multiple users are permitted by time shared operating system to share the machine at the same time. Time shared system is capable of completing each action or command in a very less time. As a result, each user need can be fulfilled in very less time. A particular user program executes in allocated time by system and after expiration of slot, system gets allocated to other user program.

So the allocation of computer resources in time slots to several programs simultaneously is in time sharing manner. Consider the example of multiple users logged in same server. The resources in server machine like CPU gets allocated to each user on time sharing basis giving the feeling to each user that only he or she is using the server machine exclusively.

The development of time sharing system was aimed to offer an interactive utilization of the computer system to its user. These systems make use of CPU scheduling and multiprogramming to offer each user with a small quantum of time slot to carry out the designated work. Many users can share the resources of computer system at the same time.

Users can execute their jobs in small time slot allocated to them. After expiration of this slot, system switches to other user and again time quantum is allocated to execute his/her jobs. As scheduling is used and time is divided as per scheduling criteria, the time sharing system offers the straight access to a large amount of users.

In this system each user feels that CPU is allocated to him or her only. The reason behind this is that, the time quantum allocated to them is very small and switching from one user to other occurs in very less time.

2.1.4 Multiprocessor Systems

QUESTIONS:
- State and describe any two advantages of multiprocessor system.
- Describe multiprocessor OS with its advantages.

Unlike the uni-processor operating systems, multiprocessor operating systems offers support for multiple processors having access to a shared memory. In this case, all data structures required by the operating system to deal with the hardware, together with the multiple CPUs, are placed into shared memory.

Multiple processors can access these data. Hence protection against simultaneous access is needed to promise consistency. Modern operating systems are designed with the intention of handling multiple processors.

Pg13END

The main aim of multiprocessor operating systems is to achieve high performance by means of multiple CPUs. A key goal is hide the presence of number of CPUs from the application.

Such transparency can be attained and is relatively straightforward as different parts of applications communicates by using same primitives as those in multitasking uniprocessor operating systems.

All the communication is made by manipulating data at shared memory locations, and it is required to protect that data against concurrent access. This protection is achieved through synchronization primitives: semaphores and monitors. Windows and Linux are multiprocessor operating systems.

2.1.5 Mainframe Operating Systems

Mainframe computers have high I/O capacity. It is common to have 1000 disks in mainframe with millions gigabyte of data. These machines are now under consideration as high-end Web servers, servers for large-scale electronic commerce sites, and servers for business-to-business transactions.

The operating systems for mainframes processes the several jobs at once, and most of which need remarkable amounts of I/O. Services offered by mainframe operating systems are:

1. Batch
2. Transaction processing
3. Timesharing

In batch processing user's interaction is not required, Job is submitted to the system and need to wait until final result is generated. For example, claims processing in an insurance company.

Transaction-processing include the handling of large number of small requests, for example, check processing at a bank or railway reservations. With timesharing systems many number of remote users can run jobs on the system at once, for example, querying a big database. OS/390 which is descendant of OS/360 is an example of mainframe OS. However, mainframe operating systems are slowly being replaced by Linux.

2.1.6 Distributed Systems

The development of powerful microprocessors and invention of the high speed networks are the two major developments in computer technology. Many machines in the same organization can be connected together through local area network and information can be transferred between machines in a very small amount of time.

As a result of these developments, it became easy and practicable to organize computing system comprising large number of machines connected by high speed networks. Over the period of last thirty years, the price of microprocessors and communications technology has constantly reduced in real terms.

Because of this, the distributed computer systems appeared as a practical substitute to uniprocessor and centralized systems. The networks of computers are present all over. Internet is composed of many networks. All these networks separately and in combination as well, share the necessary characteristics that make them pertinent topics to focus under distributed system.

2.1.6.1 Definition of Distributed Systems

A computer network is defined as a set of communicating devices that are connected together by communication links. These devices include computers, printers and other devices capable of sending and/or receiving information from other devices on the network. These devices often called as node in the network. So computer network is interconnected set of autonomous computers.

Pg14END

A distributed system is defined as set of autonomous computers that appears to its users as a single coherent system.

Users of distributed system feel that they are working with a single system. Following are the main characteristics of distributed system:

1. A distributed system comprises computers with distinct architecture and data representation. These dissimilarities and the ways all these machines communicate are hidden from users.
2. The manner in which distributed system is organized internally is also hidden from the users of the distributed system.
3. The interaction of users and applications with distributed system is in consistent and identical way, in spite of where and when interaction occurs.
4. A distributed system should allow for scaling it.
5. Distributed system should support for availability. It should be always available to the users and applications in spite of failures.
6. Failure handling should be hidden from users and applications.

2.1.6.2 Motivation

Following are the objectives behind building distributed system:

1. Resource sharing
2. Computation speedup
3. Reliability
4. Communication

1. Resource sharing

Resource sharing offers saving in cost. One printer can be shared among many users in office instead of having one printer to each individual user. There can be more saving in cost if expensive resources are shared.

The increase in connectivity and sharing also increases the security risk and to deal with it is equally important. Presently, systems offer fewer defenses against eavesdropping or intrusion on communication.

A communication can be tracked to construct a favorite profile of a particular user. This clearly violates privacy, particularly if it is done without informing the user. An allied problem with increased connectivity can also cause unnecessary communication, for example electronic junk mail, called as spam. Special information filters can be used to select inward messages based on their content.

2. Computation Speedup

Many big computations can be divided in sub-computations which can be assigned to different nodes in network so that work can be carried out in parallel. In this case, speed of computation increases. As another example, process may be migrated from heavily loaded machine to lightly loaded machine in network.

3. Reliability

System does not affect with failure of one node in network as other nodes are available in system. In case of failure, other nodes can take over computations to achieve reliability. This failure should be detected and recovered by system itself. Once the recovery is done, final computation must result in consistent state.

Pg15END

4. Communication

Machines in network communicate with each other by exchanging messages. At low level, this communication takes place through protocol stack between machines. At highest level, applications exchange these messages. Due to such communication, many users can be part of a single work to be carried out by sharing the information.

By connecting users and resources, it becomes easier to work together and exchange information. The success of the Internet is due to its straightforward protocols for exchanging files, mail, documents, audio, and video. The worldwide spread people can work together by means of groupware. Electronic commerce permits us to purchase and sell variety of goods without going to shop or even leaving home.

2.1.6.3 Types of Distributed Operating Systems

In a network, multiple machines may have different operating system installed on it. Operating systems for distributed computers are categorized as:

(a) Tightly coupled systems: It keeps a single, global view of the resources it manages. Such tightly coupled operating system is called as distributed operating system (DOS). It is useful for the management of multiprocessors and homogeneous multicomputer. DOS hides details of underlying hardware. This hardware can be shared by many processes and details remains hidden.

(b) Loosely-coupled systems: In a set of computers, each has its own OS and there is coordination between operating systems to make their own services and resources available to the others. This loosely coupled OS is called as network operating system (NOS) and is used for heterogeneous multicomputer systems.

1. Network Operating System (NOS)

If users have NOS installed on machine then they can either access resources on other machine by remote login or transfer the data from remote machine to their own machine.

1.1 Remote Login

Network operating system allows users to log in remotely. The Internet offers the telnet facility for remote login. NOS permit users to use services available on a particular machine in the network. Remote login service provided by NOS allows the user to log in remote machine from his/her terminal.

Using command for remote copy, user can copy the file from one machine to other.

1.2 Remote File Transfer

NOS offer a mechanism for remote file transfer from one computer to another. Here, each computer has its own local file system. If a user working on computer A wants to access a file on another computer B, then the file must be copied explicitly from the computer B to computer A. File Transfer Protocol (FTP) is used for such transfer in internet environment. User invokes the FTP program as:

ftp name of computer B

After entering the correct username and password, user should connect to the right subdirectory to access the required file. Suppose user want to access the file abc.txt then this file must be copied from computer B to computer A by executing following command.

get abc.txt

The location of file is not transparent to user. As file is only allowed to copy from one machine to other, many copies exists which waste the storage space. The daemon process running on remote computer watches connection request on FTP port and completes authentication of user. This daemon responds to the set of following predefined commands:

1. get: Transfer file from remote computer to local computer.

Pg16END

2. put: Transfer file from local computer to remote computer.
3. ls or dir: List files in the current directory on the remote computer.
4. cd: Change the current directory on the remote computer.

2. Distributed Operating Systems (DOS)

In a distributed operating system, access to remote and local resources seems to be in the same way. Operating system controls the data and process migration from one site to another.

2.1 Data Migration

User working on machine A can access data (such as a file) that reside at machine B. One method to data migration is to transfer the complete file to machine A. After this all access to the file is local. When the user need is completed, a copy of the file if it has been modified is sent back to machine B.

Although a small change has been made to a large file, all the data needs to be transferred. This method was used in the Andrew file system. This method of file transfer is inefficient. In other method of data transfer only those portions of the file that are actually needed for the immediate task gets transferred.

If another part of the file is needed later on, another transfer will take place. When the user no longer wants to access the file, any part of it that has been modified must be sent back to machine B. The Sun Microsystems network file system (NFS) protocol uses this method. The Microsoft SMB protocol (running on top of either TCP/IP or the Microsoft NetBEUI protocol) also allows file sharing over a network.

2.2 Computation Migration

The computation rather than the data can be transferred across the system. This approach is called computation migration. If applications need to access various large files that reside at different machines, to obtain a summary of those files. In this case, it would be more beneficial and efficient to access the files at the machine where they reside and return needed results to the machine that initiated the computation.

If the time required to transfer the data is longer than the time to execute the remote command, the remote command should be executed.

2.3 Process Migration

Process migration involves transfer of process to other machine for execution purpose. The whole process, or portion of it, may be executed at different machines. The reasons for migration are:

1. Load balancing: The processes (or sub processes) may be distributed across the network on different machines to balance the workload.
2. Computation speedup: The subprocesses of the single process can run concurrently on different machines then the total process turnaround time can be reduced.
3. Hardware preference: The particular process may need some specialized processor for execution.
4. Software preference: The needed software by process may available at only a particular machine, and either the software cannot be moved, or it is less expensive to move the process.
5. Data access: If the huge amount of data requires in the computation, it may be more efficient to have a process run remotely than to transfer all the data.

Pg17END

2.1.6.4 Difference between Distributed OS and Network OS

Distributed operating system attempts to achieve complete transparency in order to offer a single system view to the user. Whereas achieving full transparency with network operating system is not possible. As we have seen for remote login, user has to explicitly log into remote machine. In remote copy user knows the machine to which he/she is copying the files. The main advantage of network operating system is that it provides scalability.

Comparison Table:

| Aspect | Distributed OS (DOS) | Network OS (NOS) |
|--------|---------------------|------------------|
| Transparency | Very high for multiprocessor OS<br>High for multicomputer OS | Low transparency<br>User aware of remote operations |
| OS Consistency | Same operating system on all nodes | Different OS may be present on different nodes |
| OS Copies | Multiprocessor: 1 copy<br>Multicomputer: n copies | Multiple independent copies |
| Communication | Shared memory (multiprocessor)<br>Message passing (multicomputer) | Message passing only |
| Resource Management | Global and central (multiprocessor)<br>Global and distributed (multicomputer) | Distributed and autonomous |
| Scalability | No scalability (multiprocessor)<br>Moderate scalability (multicomputer) | High scalability |
| Openness | Not open, optimized for performance | More open and flexible |

2.1.7 Real Time Systems

QUESTIONS:
- Define real time operating system. List any four applications of it.

QUESTIONS:
- Explain real time OS. Explain its types.

Pg18END

For Real time operating systems time constraints are a key parameter. If the completion of particular task should happen in given time constraints or action completely must take place at a certain instant (or within a certain range), we have a hard real-time system.

In a soft real-time system, the missing of an occasional deadline is acceptable. Digital audio or multimedia systems are the examples of this class. VxWorks and QNX are the well-known real-time operating systems. Each task should be completed within the associated deadline to that task and missing a deadline can cause affects ranging from undesired to catastrophic.

The embedded systems are becoming more multifaceted and complex today. Also these systems will affect our life with more involvement. This means they will bear more and more responsibilities on their shoulders to solve real time problems to make our life easier. So real time operating system needs to be effective to manage more complex real time applications.

Real time Operating Systems must respond quickly. These systems are used in an environment where a large number of events (generally external) must be accepted and processed in a short time. Real time processing necessitates quick dealing and characterized by providing instant response. For example, a measurement from a petroleum refinery indicating that temperature is getting too high and might demand for immediate attention to avoid an explosion.

In real time operating system swapping of programs from primary to secondary is not frequent. Most of the time, processes remain in primary memory in order to provide quick response, therefore, memory management in real time system is less demanding compared to other systems.

The primary functions of the real time operating system are:

1. Management of the CPU and other resources to fulfill the requirements of an application.
2. Synchronization with and responding to the system events.
3. Efficient movement of data among processes and carrying out coordination among these processes.

Along with the primary functions discussed, there are also secondary functions which plays important role in improvement of the performance:

1. Efficient primary memory management.
2. To offer a restricted access to the computer resources.

Few more examples of real time processing are:

1. Systems controlling air traffic
2. Immediate updating offering systems
3. Systems giving information in minutes about stock prices
4. RADAR
5. Reservation system for Airlines

2.1.8 Mobile OS

Mobile operating system is used for phones, tablets and for some other mobile devices.

Personal Digital Assistants (PDAs), for example palm and pocket-PCs and cellular telephones are the examples of handheld systems. Several of such system uses special-purpose embedded operating systems. These devices are having small size and have a small amount of memory, slow processors, and small display screens.

Physical memory size of these devices is between 512 KB and 128 MB. Therefore, it is a job of operating system and applications to manage memory efficiently.

A second concern to developers of handheld devices is the speed of the processor used in the devices. Handheld devices require faster processors with compare to PC. Faster processors need more power. So it is obvious that, handheld devices require large battery size and will occupy more space for battery.

Pg19END

Therefore, most handheld devices use smaller, slower processors that consume less power. As a result, the operating system and applications must be designed not to tax the processor.

2.1.8.1 Android OS

Android operating system combines open-source code with closed source third-party applications. Android Open Source Project (AOSP) is open source part of the operating system and is totally open and free to be used and modified by anyone.

The main goal of Android is to support a rich third-party application environment, which needs a stable implementation and API for applications to run against. CDD (Compatibility Definition Document) defines the way the Android must act to be compatible with third party applications. The requirement for compatible Android device is specified in CSS.

Following are design goals of Android:

1. To offer a full open-source platform for mobile devices. The open-source part of Android is a bottom-to-top operating system stack.
2. To offer strong support for proprietary third-party applications with a robust and stable API. Maintaining the open-source and stable platform is challenging adequate for proprietary third-party applications.
3. To permit all third-party applications, including those from Google, to compete on a level playing field.
4. To offer the user an application security model, preventing them to trust on third-party applications. The operating system should provide the security to the user from misbehavior of applications, including crash and misuse of the device and the user's data on it.
5. Making mobile and user interaction easy and efficient by paying short amounts of time in many apps. User should get facility for quick interaction with all the applications. For example, quick look at new received email, receiving and sending an SMS message etc.
6. All application processes of users should be managed in such a way that, they do not have to worry about closing applications when after using them. It is possible for OS to fall as applications requires more RAM which is not available in device. So OS should be able to close and start applications as per requirement.
7. Support applications to interoperate and collaborate in rich and secure ways.
8. Creating the general purpose operating system just like desktop operating system.

2.1.8.2 Android Architecture

The Android is organized as layered architecture as shown in Fig 2.2.

Applications
Application Framework
Libraries
Android Runtime
Linux Kernel

Figure 2.2: Android Architecture

Each layer includes many program components as described below. The services offered by each layer is different from other layer and each layer offers different types of services.

Pg20END
